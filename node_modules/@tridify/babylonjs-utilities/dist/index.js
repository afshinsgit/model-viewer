var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import '@babylonjs/core/Engines/engine';
import { ArcRotateCamera, SceneLoader, StandardMaterial, PBRMaterial, Mesh, Vector3 } from '@babylonjs/core';
import "@babylonjs/loaders/glTF/2.0";
/**
 * Frame scene. First it calculates the radius of the entire scene.
 * Then it calculates this based on camera fov so that the entire building is visible in camera view.
 * Then it sets camera target to scene origin.
 * Then it moves the camera so that the model is in 45 degree angle from the model based on architecture standards.
 * Then it sets camera radius
 * Then creates collision box if meshToFrame is give
 * @param {Scene} scene - The Babylon scene to frame.
 * @param {ArcRotateCamera} orbitCamera - Optional - The orbit camera to frame. If missing, use scene active camera
 * @param {AbstractMesh[]} meshesToFrame - Optional - meshes to use for framing. If missing use all in scene.
 * @param {number} minOrbitZoom - Optional - the minimum distance that the camera can zoom to to the center of the model. If missing, third of diameter.
 */
export function frameScene(scene, orbitCamera, meshesToFrame, collisionMesh, minOrbitZoom) {
    if (orbitCamera === undefined) {
        try {
            orbitCamera = scene.activeCamera;
        }
        catch (_a) {
            throw Error('Frame scene: active scene camera is not an ArcRotateCamera');
        }
    }
    const r = getMaxBoundingDistanceFromOrigo(meshesToFrame !== undefined ? meshesToFrame : scene.meshes);
    const d = r / (Math.sin(orbitCamera.fov / 2));
    const divisor = 1.5;
    orbitCamera.setTarget(Vector3.Zero());
    orbitCamera.setPosition(new Vector3(-1 * d / divisor, 0.9 * d / divisor, -1 * d / divisor));
    if (collisionMesh) {
        orbitCamera.collisionRadius = new Vector3(8, 8, 8);
        collisionMesh.checkCollisions = true;
        collisionMesh.scaling = new Vector3(2, 2, 2);
        collisionMesh.isPickable = false;
        collisionMesh.isVisible = false;
        scene.collisionsEnabled = true;
    }
    else {
        orbitCamera.lowerRadiusLimit = minOrbitZoom !== undefined ? minOrbitZoom : (d / 3);
    }
}
/**
 * Get bounding distance.
 * @param {Scene} scene - The Babylon scene to frame.
 * @param {ArcRotateCamera} orbitCamera - The orbit camera to frame.
 * @returns {number} - The bounding distance from origo.
 */
export function getMaxBoundingDistanceFromOrigo(meshes) {
    return Math.max(...GetMeshesWithinAverageBoxCenterDeviation(meshes)
        .map(x => x.getBoundingInfo().boundingSphere.radius + Vector3.Distance(x.absolutePosition, Vector3.Zero())));
}
/**
 * Load model based from a Tridify model hash
 * @param {Scene} scene - The Babylon scene to import model into.
 * @param {string} uid - The Tridify model hash.
 */
export function loadModel(scene, uid) {
    return __awaiter(this, void 0, void 0, function* () {
        const myUrls = yield fetchGltfUrls(uid);
        if (myUrls) {
            yield myUrls.forEach((x) => __awaiter(this, void 0, void 0, function* () {
                yield SceneLoader.ImportMeshAsync("", "", x.Url, scene, null, '.gltf').then((result) => {
                    const meshes = result.meshes;
                    applyPbrMaterials(scene, meshes);
                    meshes.forEach(mesh => mesh.ifcType = x.Type);
                });
            }));
        }
    });
}
/**
* Center the imported meshes based on a standard deviation distance from each other
* @param {AbstractMesh[]} meshesToCenter - An array of meshes to center by
* @param {AbstractMesh[]} allMeshes - All meshes
* @returns {Vector3} - the vector to offset all meshes by
*/
export function centerModel(meshesToCenter, allMeshes) {
    const meshesWithinDeviation = GetMeshesWithinAverageBoxCenterDeviation(meshesToCenter);
    const offset = meshesWithinDeviation.map(x => x.getBoundingInfo().boundingBox.centerWorld)
        .reduce((a, b) => a.add(b))
        .divide(new Vector3(meshesWithinDeviation.length, meshesWithinDeviation.length, meshesWithinDeviation.length));
    allMeshes.forEach(x => x.setAbsolutePosition(x.absolutePosition.subtract(offset)));
    return offset;
}
/**
* Add a ArcRotateCamera to the scene with IFC based settings
* @param {Scene} scene - The current Babylon scene
* @returns {ArcRotateCamera} - a Babylon ArcRotateCamera
*/
export function createOrbitCamera(targetScene) {
    const camera = new ArcRotateCamera('ArcRotateCamera', 0, -Math.PI / 2, 0, Vector3.Zero(), targetScene, true);
    let cameraRadius = 0;
    camera.wheelDeltaPercentage = 0.005;
    targetScene.onBeforeRenderObservable.add(() => {
        if (cameraRadius === camera.radius)
            return;
        cameraRadius = camera.radius;
        camera.minZ = cameraRadius / 10;
    });
    camera.lowerRadiusLimit = 1;
    camera.panningSensibility = 100;
    return camera;
}
function GetMeshesWithinAverageBoxCenterDeviation(meshes) {
    const boundingBoxCenters = meshes.map(x => ({ center: x.getBoundingInfo().boundingBox.centerWorld, mesh: x }));
    const averagePosition = boundingBoxCenters.reduce((a, b) => a.add(b.center), Vector3.Zero()).divide(new Vector3(meshes.length, meshes.length, meshes.length));
    const averageDeviation = boundingBoxCenters.reduce((a, b) => a + Vector3.Distance(averagePosition, b.center), 0) / meshes.length;
    const meshesWithinDeviation = boundingBoxCenters.filter(x => Vector3.Distance(averagePosition, x.center) <= averageDeviation).map(x => x.mesh);
    return meshesWithinDeviation.length > 0 ? meshesWithinDeviation : meshes;
}
/**
* Load model based from a Tridify model hash
* @param {Scene} scene - The current Babylon scene
* @param {Array<AbstractMesh>} uid - An array of meshes to apply PBR materials to
*/
function applyPbrMaterials(scene, meshes) {
    return __awaiter(this, void 0, void 0, function* () {
        meshes.forEach((mesh) => {
            if (mesh.material) {
                const serialized = mesh.material.serialize();
                const newMat = StandardMaterial.Parse(serialized, scene, '');
                const meshmat = mesh.material;
                newMat.diffuseColor = meshmat.albedoColor;
                const pbr = PBRMaterial.Parse(serialized, scene, '');
                pbr.twoSidedLighting = true;
                if (mesh.material instanceof PBRMaterial) {
                    pbr.albedoColor = mesh.material.albedoColor;
                    pbr.useAlphaFromAlbedoTexture = true;
                    pbr.metallic = 0;
                }
                if (mesh instanceof Mesh) {
                    mesh.material = pbr;
                }
            }
        });
        return meshes;
    });
}
function fetchGltfUrls(tridifyIfcUID) {
    return __awaiter(this, void 0, void 0, function* () {
        const baseUrl = 'https://ws.tridify.com/api';
        //old conversion
        const legacyFetch = () => fetch(`${baseUrl}/shared/conversion/${tridifyIfcUID}`)
            .then(response => response.json())
            .then((responseData) => {
            const gltfUrls = responseData.ColladaUrls.filter((x) => x.split('?')[0].endsWith('.gltf'));
            const newGltfUrlFiles = [];
            gltfUrls.forEach(x => {
                var _a;
                const parsedUrl = x.split('.gltf')[0].split('_');
                const part = parsedUrl.pop();
                const UrlType = ((_a = part) === null || _a === void 0 ? void 0 : _a.includes('part')) ? parsedUrl.pop() : part;
                const UrlStorey = parsedUrl.pop();
                const UrlStoreyLevel = parsedUrl.pop();
                const GltfUrlFile = { Url: x, Type: UrlType, Format: '.gltf', Storey: !UrlStoreyLevel.includes('Tridify') ? UrlStoreyLevel + UrlStorey : UrlStorey };
                newGltfUrlFiles.push(GltfUrlFile);
            });
            return newGltfUrlFiles;
        });
        return fetch(`${baseUrl}/shared/published-links/${tridifyIfcUID}`, { mode: 'cors' })
            .then(response => {
            if (response.ok)
                return response.json()
                    .then((responseData) => {
                    const files = responseData.Conversions
                        .flatMap(x => x.Files)
                        .filter(x => x.Format === '.gltf')
                        .map(x => x);
                    return files;
                });
            return legacyFetch();
        }).catch(x => legacyFetch());
    });
}
/**
* Load Ifc data object
* @param {string} uid - conversionID.
* @param {string} property - Optional - property to load properties under ifc object.
*/
export function loadIfc(uid, property = "") {
    return __awaiter(this, void 0, void 0, function* () {
        return fetch(`https://ws.tridify.com/api/shared/conversion/${uid}/ifc/${property}`, { mode: 'cors' })
            .then(response => {
            if (!response.ok)
                throw new Error("ifc not found");
            return response.json();
        });
    });
}
//# sourceMappingURL=index.js.map